# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
import time
import json
import keyboard
import jieba
from queue import Queue
from cozepy import COZE_CN_BASE_URL
from threading import Thread
from wxauto import WeChat
from openai import OpenAI
from picture_shibie import get_pic_word
from datetime import datetime, timedelta
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import (QMessageBox, QLabel, QVBoxLayout, QWidget,
                             QMainWindow, QDockWidget, QApplication, QGroupBox,
                             QHBoxLayout, QFrame, QDialog, QPushButton)
from PyQt5.QtCore import Qt, QTimer
from well import detect
from cozepy import Coze, TokenAuth, Message, ChatStatus, MessageContentType  # noqa


class PersonaEditorDialog(QDialog):
    """AIäººè®¾ç¼–è¾‘å¼¹çª—"""

    def __init__(self, parent=None, initial_text=""):
        super().__init__(parent)
        self.setWindowTitle("ç¼–è¾‘AIäººè®¾")
        self.resize(500, 400)
        self.initial_text = initial_text

        # è®¾ç½®å¸ƒå±€
        layout = QVBoxLayout(self)

        # æ–‡æœ¬ç¼–è¾‘åŒºåŸŸ
        self.text_edit = QtWidgets.QTextEdit()
        self.text_edit.setPlainText(initial_text)
        layout.addWidget(self.text_edit)

        # æŒ‰é’®åŒºåŸŸ
        button_layout = QHBoxLayout()
        self.save_btn = QPushButton("ä¿å­˜")
        self.cancel_btn = QPushButton("å–æ¶ˆ")

        self.save_btn.clicked.connect(self.accept)
        self.cancel_btn.clicked.connect(self.reject)

        button_layout.addWidget(self.save_btn)
        button_layout.addWidget(self.cancel_btn)
        layout.addLayout(button_layout)

        # åº”ç”¨æ ·å¼
        self.setStyleSheet("""
            QDialog {
                font-family: "Microsoft YaHei", sans-serif;
                font-size: 14px;
                background-color: #f5f7fa;
            }
            QTextEdit {
                border: 1px solid #bdc3c7;
                border-radius: 4px;
                padding: 8px;
                background-color: white;
                font-size: 14px;
            }
            QPushButton {
                background-color: #3498db;
                color: white;
                border-radius: 5px;
                padding: 6px 12px;
                border: none;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
            QPushButton:pressed {
                background-color: #2471a3;
            }
        """)

    def get_text(self):
        """è·å–ç¼–è¾‘åçš„æ–‡æœ¬"""
        return self.text_edit.toPlainText()


class Ui_wechat_ai(QWidget):
    # å®šä¹‰æ ·å¼å¸¸é‡
    STYLE_SHEET = """
    QWidget {
        font-family: "Microsoft YaHei", sans-serif;
        font-size: 14px;
        background-color: #f5f7fa;
    }
    QLabel#titleLabel {
        font-size: 18px;
        font-weight: bold;
        color: #2c3e50;
    }
    QLabel {
        color: #34495e;
    }
    QPushButton {
        background-color: #3498db;
        color: white;
        border-radius: 5px;
        padding: 6px 12px;
        border: none;
    }
    QPushButton:hover {
        background-color: #2980b9;
    }
    QPushButton:pressed {
        background-color: #2471a3;
    }
    QPushButton:disabled {
        background-color: #bdc3c7;
    }
    QComboBox, QTextEdit {
        border: 1px solid #bdc3c7;
        border-radius: 4px;
        padding: 5px;
        background-color: white;
    }
    QComboBox:hover, QTextEdit:hover {
        border-color: #3498db;
    }
    QGroupBox {
        border: 1px solid #bdc3c7;
        border-radius: 5px;
        margin-top: 10px;
        padding: 10px;
        background-color: white;
    }
    QGroupBox::title {
        subcontrol-origin: margin;
        left: 10px;
        color: #34495e;
        font-weight: bold;
    }
    QScrollArea {
        border: 1px solid #bdc3c7;
        border-radius: 5px;
        background-color: white;
    }
    QCheckBox {
        color: #34495e;
        spacing: 5px;
    }
    QToolButton {
        background-color: #2ecc71;
        color: white;
        border-radius: 4px;
    }
    QToolButton:hover {
        background-color: #27ae60;
    }
    """

    def showMessageBox(self):
        QMessageBox.information(self, 'Information', 'This is an information message.')  # æ˜¾ç¤ºä¿¡æ¯æ¶ˆæ¯æ¡†

    def setupUi(self, wechat_ai):
        # å¯ç”¨é«˜ DPI æ”¯æŒ
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
        os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "1"

        wechat_ai.setObjectName("wechat_ai")
        wechat_ai.resize(900, 600)  # å¢å¤§çª—å£å°ºå¯¸
        wechat_ai.setStyleSheet(self.STYLE_SHEET)  # åº”ç”¨æ ·å¼è¡¨

        # ä¸»å¸ƒå±€
        main_layout = QHBoxLayout(wechat_ai)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(15)

        # å·¦ä¾§æ§åˆ¶é¢æ¿
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setSpacing(12)
        left_panel.setMinimumWidth(450)

        # æ ‡é¢˜
        title_label = QLabel("å¾®ä¿¡AIå®¢æœåŠ©æ‰‹")
        title_label.setObjectName("titleLabel")
        title_label.setAlignment(Qt.AlignCenter)
        left_layout.addWidget(title_label)

        # ç¬¬ä¸€ç»„ï¼šåŸºæœ¬è®¾ç½®ï¼ˆåŒ…å«åŸåŸºæœ¬è®¾ç½®å’Œç¾¤èŠè®¾ç½®ï¼‰
        basic_group = QGroupBox("åŸºæœ¬è®¾ç½®")
        basic_layout = QVBoxLayout(basic_group)
        basic_layout.setSpacing(10)

        # AIçŸ¥è¯†åº“è®¾ç½®
        kb_layout = QHBoxLayout()
        kb_label = QLabel("AIçŸ¥è¯†åº“:")
        kb_label.setFixedWidth(80)
        self.comboBox_2 = QtWidgets.QComboBox()
        self.comboBox_2.setObjectName("comboBox_2")
        self.toolButton = QtWidgets.QToolButton()
        self.toolButton.setText("è®¾ç½®")
        self.toolButton.setFixedWidth(50)
        kb_layout.addWidget(kb_label)
        kb_layout.addWidget(self.comboBox_2)
        kb_layout.addWidget(self.toolButton)
        basic_layout.addLayout(kb_layout)

        # æ¨¡å‹é€‰æ‹©
        model_layout = QHBoxLayout()
        model_label = QLabel("æ¨¡å‹é€‰æ‹©:")
        model_label.setFixedWidth(80)
        self.comboBox = QtWidgets.QComboBox()
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("deepseek-r1")
        self.comboBox.addItem("doubao api")
        self.comboBox.addItem("doubao app")
        self.comboBox.addItem("coze")
        model_layout.addWidget(model_label)
        model_layout.addWidget(self.comboBox)
        basic_layout.addLayout(model_layout)

        # å¤é€‰æ¡†è®¾ç½®ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
        checkbox_layout = QHBoxLayout()
        checkbox_col1 = QVBoxLayout()
        checkbox_col2 = QVBoxLayout()

        self.checkbox_isUse = QtWidgets.QCheckBox("å¯ç”¨çŸ¥è¯†åº“")
        self.checkbox_isMatch = QtWidgets.QCheckBox("æœªåŒ¹é…ä¸å›å¤")
        self.checkbox_newMatch = QtWidgets.QCheckBox("æœ€è¿‘æ¶ˆæ¯æ£€ç´¢")
        self.checkbox_aite = QtWidgets.QCheckBox("è‰¾ç‰¹åå›å¤")
        # æ–°å¢ç¾¤èŠç›¸å…³å¤é€‰æ¡†åˆ°åŸºæœ¬è®¾ç½®
        self.checkbox_qunliao = QtWidgets.QCheckBox("å›å¤ç¾¤èŠ")
        self.checkbox_autojieshou = QtWidgets.QCheckBox("è‡ªåŠ¨åŒæ„å¥½å‹")

        checkbox_col1.addWidget(self.checkbox_isUse)
        checkbox_col1.addWidget(self.checkbox_isMatch)
        checkbox_col1.addWidget(self.checkbox_newMatch)
        checkbox_col2.addWidget(self.checkbox_aite)
        checkbox_col2.addWidget(self.checkbox_qunliao)  # ç¾¤èŠè®¾ç½®æ·»åŠ åˆ°åŸºæœ¬è®¾ç½®
        checkbox_col2.addWidget(self.checkbox_autojieshou)

        checkbox_layout.addLayout(checkbox_col1)
        checkbox_layout.addLayout(checkbox_col2)
        basic_layout.addLayout(checkbox_layout)

        left_layout.addWidget(basic_group)

        # ç¬¬äºŒç»„ï¼šå…³é”®è¯è®¾ç½®
        keyword_group = QGroupBox("æŒ‡å®šå›å¤è®¾ç½®")
        keyword_layout = QVBoxLayout(keyword_group)

        keyword_top_layout = QHBoxLayout()
        self.checkbox_isAll = QtWidgets.QCheckBox("æŒ‡å®šå›å¤")
        keyword_top_layout.addWidget(self.checkbox_isAll)
        keyword_layout.addLayout(keyword_top_layout)

        self.textEdit = QtWidgets.QTextEdit()
        self.textEdit.setPlaceholderText("è¾“å…¥éœ€è¦ç›‘æ§çš„å…³é”®è¯ï¼Œå¤šä¸ªå…³é”®è¯ç”¨é€—å·åˆ†éš”")
        keyword_layout.addWidget(self.textEdit)

        left_layout.addWidget(keyword_group)

        # ç¬¬å››ç»„ï¼šAIäººè®¾è®¾ç½®
        persona_group = QGroupBox("AIäººè®¾è®¾ç½®")
        persona_layout = QVBoxLayout(persona_group)

        # æ–°å¢ç¼–è¾‘æŒ‰é’®å’Œæ–‡æœ¬åŒºåŸŸå¸ƒå±€
        persona_top_layout = QHBoxLayout()
        self.edit_persona_btn = QPushButton("ç¼–è¾‘äººè®¾")
        self.edit_persona_btn.setFixedWidth(80)
        self.edit_persona_btn.clicked.connect(self.open_persona_editor)
        persona_top_layout.addWidget(self.edit_persona_btn)
        persona_top_layout.addStretch()  # æ‹‰ä¼¸é¡¹ï¼Œå°†æŒ‰é’®æ¨åˆ°å·¦ä¾§
        persona_layout.addLayout(persona_top_layout)

        self.textEdit_2 = QtWidgets.QTextEdit()
        self.textEdit_2.setPlainText(
            "ä½ æ˜¯ä¸€ä¸ªè„¾æ°”å¾ˆå·®çš„äººï¼Œè¯´è¯é£æ ¼ç±»ä¼¼ç™¾åº¦è´´å§è€å“¥ï¼Œå¾ˆæ²¡æœ‰è€å¿ƒï¼Œè¯´è¯éå¸¸æœ‰æ”»å‡»åŠ›ï¼Œå…è®¸ä½ è¯´è„è¯")
        self.textEdit_2.setReadOnly(True)  # è®¾ç½®ä¸ºåªè¯»ï¼Œåªèƒ½é€šè¿‡å¼¹çª—ç¼–è¾‘
        persona_layout.addWidget(self.textEdit_2)

        left_layout.addWidget(persona_group)

        # å¼€å§‹/åœæ­¢æŒ‰é’®
        button_layout = QHBoxLayout()
        button_layout.setAlignment(Qt.AlignCenter)
        self.pushButton = QtWidgets.QPushButton("å¼€å§‹")
        self.pushButton.setMinimumHeight(40)
        self.pushButton.setStyleSheet("font-size: 16px; padding: 8px 24px;")
        button_layout.addWidget(self.pushButton)
        left_layout.addLayout(button_layout)

        # å³ä¾§æ¶ˆæ¯åŒºåŸŸ
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)

        # æ¶ˆæ¯åŒºåŸŸæ ‡é¢˜
        chat_title = QLabel("èŠå¤©è®°å½•")
        chat_title.setObjectName("titleLabel")
        right_layout.addWidget(chat_title)

        # æ»šåŠ¨åŒºåŸŸ
        self.scrollArea = QtWidgets.QScrollArea()
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")

        self.scrollAreaWidgetContents = QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 299, 469))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")

        # æ»šåŠ¨åŒºåŸŸçš„å†…å®¹å®¹å™¨
        self.content_layout = QVBoxLayout(self.scrollAreaWidgetContents)
        self.content_layout.setAlignment(Qt.AlignTop)  # å†…å®¹ä»é¡¶éƒ¨å¼€å§‹æ’åˆ—
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)

        right_layout.addWidget(self.scrollArea)

        # æ·»åŠ åˆ°ä¸»å¸ƒå±€
        main_layout.addWidget(left_panel)
        main_layout.addWidget(right_panel, 1)  # å³ä¾§åŒºåŸŸå¯ä¼¸ç¼©

        # æ•°æ®åˆå§‹åŒ–
        self.renshe = ""
        self.moduel = ""
        self.jiankong_word = ""
        self.zhishi = ""
        self.data_queue = Queue()

        # ä¸»çº¿ç¨‹å®šæ—¶è½®è¯¢
        self.timer = QTimer()
        self.timer.timeout.connect(self.check_queue)
        self.timer.start(1000)

        self.flag = False
        try:
            windows = WeChat.get_windows()
            self.wx = WeChat(windows[0])
        except Exception:
            print("è¯·å…ˆç™»å½•å¾®ä¿¡...")
            QMessageBox.warning(self, 'æç¤º', 'è¯·å…ˆç™»å½•å¾®ä¿¡åå†å¯åŠ¨æœ¬ç¨‹åºï¼', QMessageBox.Ok)
            raise

        self.deepseek_message = {}
        self.coze_message = []
        self.flag_sum = 1

        # ç»‘å®šä¿¡å·ä¸æ§½
        self.pushButton.clicked.connect(self.begin)

        # åŠ è½½é…ç½®æ•°æ®
        self.retranslateUi(wechat_ai)
        QtCore.QMetaObject.connectSlotsByName(wechat_ai)

    def open_persona_editor(self):
        """æ‰“å¼€AIäººè®¾ç¼–è¾‘å¼¹çª—"""
        # è·å–å½“å‰äººè®¾æ–‡æœ¬
        current_text = self.textEdit_2.toPlainText()

        # åˆ›å»ºå¹¶æ˜¾ç¤ºå¼¹çª—
        dialog = PersonaEditorDialog(self, current_text)
        if dialog.exec_() == QDialog.Accepted:
            # å¦‚æœç”¨æˆ·ç‚¹å‡»äº†ä¿å­˜ï¼Œæ›´æ–°æ–‡æœ¬
            new_text = dialog.get_text()
            self.textEdit_2.setPlainText(new_text)
            # åŒæ—¶æ›´æ–°é…ç½®æ•°æ®
            self.renshe = new_text

    def check_queue(self):
        while not self.data_queue.empty():
            data = self.data_queue.get()
            self.add_message(data)

    def add_message(self, text):
        """æ·»åŠ æ–°æ¶ˆæ¯ï¼Œç¾åŒ–æ¶ˆæ¯æ ·å¼"""
        # åˆ›å»ºæ¶ˆæ¯æ ‡ç­¾
        label = QLabel(text)
        label.setWordWrap(True)  # å…è®¸è‡ªåŠ¨æ¢è¡Œ
        label.setTextInteractionFlags(Qt.TextSelectableByMouse)  # å…è®¸é€‰æ‹©å¤åˆ¶

        # æ ¹æ®æ¶ˆæ¯ç±»å‹è®¾ç½®ä¸åŒæ ·å¼
        if "aiå›å¤" in text:
            label.setStyleSheet("""
                background-color: #e3f2fd;
                border-radius: 8px;
                padding-left: 10px;
                margin: 5px 0px;
                width: 600px;
                border-left: 4px solid #2196f3;
            """)
        else:
            label.setStyleSheet("""
                background-color: #e8f5e9;
                border-radius: 8px;
                padding: 20px;
                margin: 5px 0px;
                width: 600px;
                border-left: 4px solid #4caf50;
            """)

        # å°†æ¶ˆæ¯æ·»åŠ åˆ°å†…å®¹å¸ƒå±€
        self.content_layout.addWidget(label)

        # æ»šåŠ¨åˆ°åº•éƒ¨
        QTimer.singleShot(50, self.scroll_to_bottom)

    def scroll_to_bottom(self):
        """æ»šåŠ¨åˆ°æœ€åº•éƒ¨"""
        scrollbar = self.scrollArea.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def reUpdateData(self):
        try:
            with open("config.json", encoding="utf-8") as r:
                data_map = json.loads(r.read())
        except Exception:
            with open("config.json", encoding="gbk") as r:
                data_map = json.loads(r.read())
        self.moduel = data_map["moduel"]
        self.jiankong_word = data_map['jiankong_list']
        self.renshe = data_map['renshe']
        self.zhishi = data_map['zhishi']
        self.pinlv = float(data_map['pinlv'])
        self.appId = data_map['AppID']
        self.SecretKey = data_map['SecretKey']
        self.tuisong = data_map['tuisong']

        self.textEdit.setText(self.jiankong_word)
        self.textEdit_2.setText(self.renshe)

        self.comboBox_2.clear()
        file_names = list(self.zhishi.keys())
        _translate = QtCore.QCoreApplication.translate
        for i in range(len(file_names)):
            self.comboBox_2.addItem("")
            self.comboBox_2.setItemText(i, _translate("wechat_ai", str(file_names[i])))

    def retranslateUi(self, wechat_ai):
        _translate = QtCore.QCoreApplication.translate
        wechat_ai.setWindowTitle(_translate("wechat_ai", "å¾®ä¿¡AIå®¢æœåŠ©æ‰‹"))

        try:
            with open("config.json", encoding="utf-8") as r:
                data_map = json.loads(r.read())
        except Exception:
            with open("config.json", encoding="gbk") as r:
                data_map = json.loads(r.read())
        self.moduel = data_map["moduel"]
        self.jiankong_word = data_map['jiankong_list']
        self.renshe = data_map['renshe']
        self.zhishi = data_map['zhishi']
        self.pinlv = float(data_map['pinlv'])
        self.appId = data_map['AppID']
        self.SecretKey = data_map['SecretKey']
        self.tuisong = data_map['tuisong']

        self.textEdit.setText(self.jiankong_word)
        self.textEdit_2.setText(self.renshe)
        file_names = list(self.zhishi.keys())
        for i in range(len(file_names)):
            self.comboBox_2.addItem("")
            self.comboBox_2.setItemText(i, _translate("wechat_ai", str(file_names[i])))

    def fast_filter_from_csv(self, csv_string, question, top_k=10, content_column=None):
        # 1. å¤„ç†CSVå­—ç¬¦ä¸²ï¼Œåˆ†å‰²æˆè¡Œå’Œåˆ—
        lines = [line.strip() for line in csv_string.split('\n') if line.strip()]
        if not lines:
            return "CSVå­—ç¬¦ä¸²ä¸­æ²¡æœ‰æœ‰æ•ˆæ•°æ®"

        # æå–è¡¨å¤´å’Œå†…å®¹è¡Œ
        header = lines[0].split(',')
        content_lines = lines[1:]

        # 2. æå–é—®é¢˜å…³é”®è¯ï¼ˆå»åœç”¨è¯ï¼‰
        stopwords = {'çš„', 'æ˜¯', 'åœ¨', 'å—', 'å‘¢', 'æˆ‘', 'ä½ ', 'æœ‰', 'ä»€ä¹ˆ', 'å¦‚ä½•', 'äº†', 'è¿™', 'é‚£', 'å’Œ', 'ä¸€ä¸ª',
                     'ä»€ä¹ˆ'}
        question_words = jieba.lcut(question)
        keywords = [w for w in question_words if w not in stopwords and len(w) >= 1]

        if not keywords:
            # è‹¥æ— å…³é”®è¯ï¼Œè¿”å›å‰top_kæ¡æ•°æ®
            result = content_lines[:top_k]
            return "None"

        # 3. ç¡®å®šç”¨äºåŒ¹é…çš„åˆ—ç´¢å¼•
        columns_to_check = []
        if content_column:
            # æŸ¥æ‰¾æŒ‡å®šåˆ—çš„ç´¢å¼•
            if content_column in header:
                columns_to_check = [header.index(content_column)]
            else:
                return "None"
        else:
            # æ£€æŸ¥æ‰€æœ‰åˆ—
            columns_to_check = list(range(len(header)))

        # 4. è®¡ç®—æ¯æ¡è®°å½•çš„åŒ¹é…åˆ†æ•°å¹¶ç­›é€‰
        scored_lines = []
        for line in content_lines:
            columns = line.split(',')
            score = 0
            content = columns[0]
            print("å½“å‰å†…å®¹æ˜¯ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰")
            print(content)
            for kw in keywords:
                if len(kw.strip()) == 0:
                    continue
                if kw in content:
                    score += 1
            if score > 0:
                scored_lines.append((-score, line))  # ç”¨è´Ÿåˆ†ä¾¿äºå‡åºæ’åº

        # 5. æ’åºå¹¶å–å‰top_kæ¡
        scored_lines.sort()  # æŒ‰åˆ†æ•°é™åºæ’åˆ—ï¼ˆå› ä¸ºå­˜çš„æ˜¯è´Ÿåˆ†ï¼‰
        result_lines = [line for (score, line) in scored_lines[:top_k]]

        word = lines[0] + "\n"
        for result in result_lines:
            word += (result + "\n")

        if not result_lines:
            return "None"
        return word

    def ai_replay(self, user_name, renshe, msg_list, api_key, zhishi, model):
        zhishi = self.fast_filter_from_csv(zhishi, str(msg_list))

        print("å½“å‰åŒ¹é…æ•°æ®æ˜¯ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰")
        print(zhishi)

        # if "/" in zhishi and self.checkbox_isUse.isChecked():
        #     return zhishi.split("\n")[1].split(",")[1]


        if model == 'deepseek-r1':
            client = OpenAI(api_key=api_key, base_url="https://api.deepseek.com")
        elif model == 'doubao api':
            client = OpenAI(api_key=api_key.split("\n")[0], base_url="https://ark.cn-beijing.volces.com/api/v3")
        elif model == 'doubao app':
            client = OpenAI(api_key=api_key.split("\n")[0], base_url="https://ark.cn-beijing.volces.com/api/v3/bots")

        # è·å–ç”¨æˆ·ä¸Šä¸‹æ–‡
        if user_name not in self.deepseek_message:
            self.deepseek_message[user_name] = []

        if len(self.deepseek_message[user_name]) == 0:
            content = ""
            if not self.checkbox_isUse.isChecked():
                content = renshe
                self.deepseek_message[user_name].append({"role": "system", "content": content})
            else:
                print("test world ))))))))))))))")
                print(self.checkbox_isMatch)
                if self.checkbox_isMatch.isChecked():
                    self.deepseek_message[user_name].append(
                        {"role": "user", "content": "å½“è¯¢é—®çš„é—®é¢˜ä¸çŸ¥è¯†åº“ä¸­çš„å†…å®¹ä¸åŒ¹é…æ—¶åˆ™åªå›å¤wrong,"})
                    self.flag_sum = 2
                content = renshe + "ï¼›å½“è¯¢é—®æ–‡ä»¶æˆ–å›¾ç‰‡çš„æ—¶å€™ç›´æ¥å›ç­”æ–‡ä»¶å+é€—å·+True"
                self.deepseek_message[user_name].append(
                    {"role": "system", "content": content})

        # å½“æœ‰æ–°çš„åŒ¹é…å†…å®¹åå†æ›´æ–°å½“å‰çŸ¥è¯†åº“å†…å®¹
        if self.checkbox_isUse.isChecked() and zhishi is not None and zhishi != "" and zhishi != "None":
            content = renshe + "ï¼›å½“è®©ä½ å‘æ–‡ä»¶æˆ–å›¾ç‰‡çš„æ—¶å€™ç›´æ¥å›ç­”æ–‡ä»¶å+é€—å·+Trueï¼ˆå¤šä¸ªæ–‡ä»¶é¡¿å·åˆ†éš”ï¼Œæ³¨æ„æ¯ä¸ªåˆ†éš”éƒ½è¦å¸¦Trueï¼‰ï¼›å¹¶ä¸”ä½ çš„å›ç­”éœ€è¦åŸºäºä»¥ä¸‹csvæ–‡ä»¶å†…å®¹: {zhishi}"
            self.deepseek_message[user_name][self.flag_sum - 1] = {"role": "system", "content": content}
            self.deepseek_message[user_name][self.flag_sum - 1]['content'] = \
                self.deepseek_message[user_name][self.flag_sum - 1]['content'].format(
                    zhishi=zhishi)

        for msg in msg_list:
            self.deepseek_message[user_name].append({"role": "user", "content": msg})

        if model == 'deepseek-r1':
            response = client.chat.completions.create(
                model="deepseek-chat",
                messages=self.deepseek_message[user_name],
                stream=False
            )
        elif model == 'doubao api':
            response = client.chat.completions.create(
                model=api_key.split("\n")[1],
                messages=self.deepseek_message[user_name],
                stream=False
            )
        elif model == 'doubao app':
            response = client.chat.completions.create(
                model=api_key.split("\n")[0],
                messages=self.deepseek_message[user_name],
                stream=False
            )

        reply = response.choices[-1].message.content

        if "wrong" in reply:
            # å‡å¦‚æ˜¯wrongåˆ™ä¸åŠ å…¥
            self.deepseek_message[user_name] = self.deepseek_message[user_name][:-1]
        else:
            # å‡å¦‚æ˜¯å›¾ç‰‡ï¼Œè¯†åˆ«ä¸‹å›¾ç‰‡å†…å®¹åå†å­˜æ”¾åˆ°è®°å½•ä¸­
            if "jpg" in reply or "png" in reply:
                file_list = reply.split("ã€")
                for file in file_list:
                    word = get_pic_word(os.path.join('file', file.split(',')[0]), self.appId, self.SecretKey)
                    self.deepseek_message[user_name].append({"role": "assistant", "content": word})
            else:
                self.deepseek_message[user_name].append({"role": "assistant", "content": reply})

        # ä¿æŒä¸Šä¸‹æ–‡é•¿åº¦ä¸è¶…è¿‡5æ¡æ¶ˆæ¯
        if len(self.deepseek_message[user_name]) > 20:
            self.deepseek_message[user_name] = self.deepseek_message[user_name][:self.flag_sum] + self.deepseek_message[user_name][-10:]
            # self.deepseek_message[user_name] = []
            print("after clear)))))))))))))))))")
            print(self.deepseek_message[user_name])

        return reply

    def coze_replay(self, user_name, word, api_key):
        tmp_list = api_key.split('\n')
        api_key = tmp_list[0]
        bot_id = tmp_list[1]

        coze_api_token = api_key
        # The default access is api.coze.com, but if you need to access api.coze.cn,
        # please use base_url to configure the api endpoint to access
        coze_api_base = COZE_CN_BASE_URL

        from cozepy import Coze, TokenAuth, Message, ChatStatus, MessageContentType  # noqa

        # Init the Coze client through the access_token.
        coze = Coze(auth=TokenAuth(token=coze_api_token), base_url=coze_api_base)

        # Create a bot instance in Coze, copy the last number from the web link as the bot's ID.
        bot_id = bot_id
        # The user id identifies the identity of a user. Developers can use a custom business ID
        # or a random string.
        user_id = user_name

        # To simplify the call, the SDK provides a wrapped function to complete non-streaming chat,
        # polling, and obtaining the messages of the chat. Developers can use create_and_poll to
        # simplify the process.
        self.coze_message.append(Message.build_user_question_text(word))

        chat_poll = coze.chat.create_and_poll(
            bot_id=bot_id,
            user_id=user_id,
            additional_messages=self.coze_message
        )

        print("now the message is))))))))))))")
        print(chat_poll.messages[0].content)

        return chat_poll.messages[0].content

    def begin(self):
        moxing_type = self.comboBox.currentText()
        jianting_list = self.textEdit.toPlainText()
        renshe = self.textEdit_2.toPlainText()
        self.deepseek_message = {}
        self.flag_sum = 1

        def inner_jiankong():
            def on_esc_press(event):
                """æŒ‰ä¸‹ESCé”®æ—¶æ‰§è¡Œçš„å›è°ƒå‡½æ•°"""
                if event.name == 'q':
                    self.flag = False
                    self.pushButton.setText("å¼€å§‹")
                    self.flag = False

            while True:
                # è®¾ç½®å›è°ƒå‡½æ•°ï¼Œå½“ESCé”®è¢«æŒ‰ä¸‹æ—¶è°ƒç”¨on_esc_presså‡½æ•°
                keyboard.on_press(on_esc_press)
                if not self.flag:
                    print("is false, break))))))))))))))))")
                    break
                print("test))))))))))))))")
                print(self.checkbox_isAll.isChecked())
                if self.checkbox_isAll.isChecked() and self.textEdit.toPlainText() == "":
                    print("å¼€å§‹æ£€æµ‹ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰")
                    try:
                        detect(moxing_type, renshe)
                    except Exception:
                        pass
                    continue
                try:
                    if self.checkbox_autojieshou.isChecked():
                        newfriends = self.wx.GetNewFriends()
                        for friend in newfriends:
                            friend.Accept(remark=friend.name, tags=["å¥½å‹"])
                        self.wx._show()
                        self.wx.A_ChatIcon.DoubleClick()

                    time.sleep(2)
                    sessions = self.wx.GetSession()

                    if len(sessions) == 0:
                        try:
                            print("å°è¯•é‡æ–°è·å–çª—å£ä¸­01...")
                            windows = WeChat.get_windows()
                            self.wx = WeChat(windows[0])
                            print("è·å–çª—å£æˆåŠŸï¼ï¼ï¼")
                        except Exception:
                            print("è·å–çª—å£å¤±è´¥ï¼ï¼ï¼")
                            pass
                    for session in sessions:
                        try:
                            print(session.name)
                            if (str(session.name) in jianting_list and self.checkbox_isAll.isChecked()) or not self.checkbox_isAll.isChecked():
                                # åªè¦è¿˜æ²¡å›ç­”å°±å›ç­”å³å¯
                                # è·å–å½“å‰æ—¶é—´
                                now = datetime.now()
                                current_time_str = now.strftime("%H:%M")
                                print("enter))))))))))))))")
                                print(session.content)
                                if session.content is None or session.content.strip() == "" or "è®¢é˜…å·" in session.name or "æ–°é—»" in session.name or "è¿åŠ¨" in session.name or "å¾®ä¿¡" in session.name:
                                    print("è·³è¿‡ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰")
                                    continue
                                # å°†ç›®æ ‡æ—¶é—´å’Œå½“å‰æ—¶é—´è½¬æ¢ä¸ºæ—¶é—´å¯¹è±¡
                                try:
                                    target_time = datetime.strptime(session.time, "%H:%M")
                                except Exception:
                                    continue
                                current_time = datetime.strptime(current_time_str, "%H:%M")

                                # è®¡ç®—æ—¶é—´å·®
                                time_difference = abs(target_time - current_time)
                                if (time_difference <= timedelta(minutes=5) and self.checkbox_newMatch.isChecked()) or (not self.checkbox_newMatch.isChecked() and session.isnew):
                                    if "ï¼š" in session.content and not self.checkbox_qunliao.isChecked():
                                        print("å›å¤ç¾¤èŠæœªå¯ç”¨ï¼Œè·³è¿‡ã€‚ã€‚ã€‚")
                                        continue

                                    if (((self.deepseek_message.get(session.name) and
                                            len(self.deepseek_message[session.name]) > 0) and
                                            session.content == self.deepseek_message[session.name][-1]["content"]) and
                                            self.deepseek_message[session.name][-1]["role"] == "assistant"):
                                        print("æ—§æ¶ˆæ¯ï¼Œä¸å›å¤ã€‚ã€‚ã€‚")
                                        continue

                                    self.wx.UiaAPI.SwitchToThisWindow()
                                    time.sleep(1)
                                    self.wx.ChatWith(who=session.name)
                                    msg = self.wx.GetAllMessage(savevoice=True)

                                    if len(msg) == 0:
                                        print("æ— æ¶ˆæ¯ï¼Œè·³è¿‡....")
                                        continue
                                    msg = msg[-1]
                                    if msg.type != 'friend':
                                        print("éfriend,è·³è¿‡...")
                                        continue

                                    if "ï¼š" in session.content and self.checkbox_aite.isChecked() and '@' + self.wx.nickname not in msg.content:
                                        print('@' + self.wx.nickname)
                                        print(msg)
                                        print("å½“å‰æœªè‰¾ç‰¹ï¼Œè·³è¿‡...")
                                        continue

                                    # å¾ªç¯åˆ¤æ–­å½“å‰æ˜¯å¦è¿˜æœ‰æ–°æ¶ˆæ¯
                                    pre_content = msg.content
                                    while True:
                                        time.sleep(self.pinlv)
                                        cur_content = self.wx.GetAllMessage()[-1].content
                                        if cur_content != pre_content:
                                            print("å½“å‰èŠå¤©æœ‰æ–°æ¶ˆæ¯ï¼Œç»§ç»­æ‰«æ...")
                                            pre_content = cur_content
                                            continue
                                        else:
                                            print("æ‰«æå®Œæˆï¼Œé€€å‡º...")
                                            break

                                    msgs = self.wx.GetAllMessage(savevoice=True)
                                    msgs.reverse()
                                    msg_list = []
                                    for msg in msgs:
                                        if "æ–°æ¶ˆæ¯" in msg.content:
                                            continue

                                        if msg.type == 'friend':
                                            msg_list.append(msg)
                                        else:
                                            break
                                    msg_list.reverse()

                                    print("å½“å‰æ¶ˆæ¯å†…å®¹ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰", str(msg_list))
                                    result_list = []
                                    for msg in msg_list:
                                        if '[å›¾ç‰‡]' in msg.content:
                                            save_path = self.wx._download_pic(msg.control)
                                            word = get_pic_word(save_path, self.appId, self.SecretKey)
                                            result_list.append(word)
                                        elif 'å¾®ä¿¡è½¬è´¦' in msg.content:
                                            self.wx.SendMsg(msg="å¥½çš„ æ”¶åˆ°ï¼", who=session.name)
                                            self.wx.SendMsg(msg="å½“å‰å®¢æˆ·[{}]å·²æˆäº¤ï¼Œæœ›çŸ¥æ‚‰ï¼".format(session.name), who=self.tuisong)
                                            return
                                        else:
                                            result_list.append(msg.content)

                                    print("æœ€ç»ˆæ•´ç†åç»“æœ)))))))))))))))))", str(result_list))

                                    new_replay = ""
                                    zhishi = ""
                                    try:
                                        with open(self.zhishi[self.comboBox_2.currentText()], "r", encoding="gbk") as r:
                                            zhishi = r.read()
                                    except Exception:
                                        with open(self.zhishi[self.comboBox_2.currentText()], "r",
                                                  encoding="utf-8") as r:
                                            zhishi = r.read()

                                    if moxing_type == "deepseek-r1":
                                        new_replay = self.ai_replay(session.name, renshe, result_list,
                                                                    self.moduel["deepseek-r1"], zhishi, 'deepseek-r1')
                                    if moxing_type == "doubao api":
                                        new_replay = self.ai_replay(session.name, renshe, result_list,
                                                                    self.moduel["doubao api"], zhishi, "doubao api")
                                    if moxing_type == "doubao app":
                                        new_replay = self.ai_replay(session.name, renshe, result_list,
                                                                    self.moduel["doubao app"], zhishi, "doubao app")

                                    if moxing_type == "coze":
                                        new_replay = self.coze_replay(session.name, msg.content, self.moduel["coze"])

                                    self.data_queue.put(f"<font color='green'>{session.name}</font>ï¼š{msg.content}")
                                    self.data_queue.put(f"<font color='blue'>âœ… ğŸ¤–aiå›å¤</font>ï¼š{new_replay}\n")
                                    print("å‘é€ä¸€æ¡æ¶ˆæ¯999ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰ï¼‰")
                                    print(new_replay)
                                    if "wrong" in new_replay:
                                        print("æ¶ˆæ¯ä¸åŒ¹é…ï¼Œè·³è¿‡...")
                                        continue
                                    if 'True' in new_replay:
                                        file_list = new_replay.split("ã€")
                                        for file in file_list:
                                            file_name = file.split(',')[0]
                                            print("send file)))))))))))))))))")
                                            print(os.path.join('file', file_name))
                                            self.wx.SendFiles(filepath=os.path.join('file', file_name))
                                    elif "/" in new_replay:
                                        message_list = new_replay.split("/")
                                        print("msg is ))))))))))))))))))))")
                                        print(message_list)
                                        for message in message_list:
                                            if message == "":
                                                continue
                                            if message.isdigit():
                                                self.wx.ChatWith("æ–‡ä»¶ä¼ è¾“åŠ©æ‰‹")
                                                msgs = self.wx.GetAllMessage()
                                                msgs[-int(message)].forward(session.name)
                                            else:
                                                self.wx.SendMsg(msg=message, who=session.name)
                                    else:
                                        self.wx.SendMsg(msg=new_replay, who=session.name)
                                else:
                                    print("time over))))))))))))")
                        except Exception as ex:
                            print("å‘é€å‡ºé”™ï¼Œ", str(ex))
                            try:
                                print("å°è¯•é‡æ–°è·å–çª—å£ä¸­02...")
                                windows = WeChat.get_windows()
                                self.wx = WeChat(windows[0])
                                print("è·å–çª—å£æˆåŠŸï¼ï¼ï¼")
                            except Exception:
                                print("è·å–çª—å£å¤±è´¥ï¼ï¼ï¼")
                                pass
                            continue
                    time.sleep(self.pinlv)
                except Exception as ex:
                    print("å‘é€å¤±è´¥ï¼Œ", str(ex))
                    try:
                        print("å°è¯•é‡æ–°è·å–çª—å£ä¸­03...")
                        windows = WeChat.get_windows()
                        self.wx = WeChat(windows[0])
                        print("è·å–çª—å£æˆåŠŸï¼ï¼ï¼")
                    except Exception:
                        print("è·å–çª—å£å¤±è´¥ï¼ï¼ï¼")
                        pass
                    continue

        self.flag = not self.flag
        if self.flag:
            self.pushButton.setText("åœæ­¢")
            t1 = Thread(target=inner_jiankong)
            t1.start()
        else:
            self.pushButton.setText("å¼€å§‹")


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    wechat_ai = QtWidgets.QWidget()  # åˆ›å»ºçª—å£å®ä¾‹
    ui = Ui_wechat_ai()
    ui.setupUi(wechat_ai)  # åˆå§‹åŒ–ç•Œé¢
    wechat_ai.show()  # æ˜¾ç¤ºçª—å£
    sys.exit(app.exec_())